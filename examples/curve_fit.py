'''Curve fitting example with scipy and numpy.

Change the file path in read_data to point into the right place.
'''
from scipy.optimize import curve_fit
import numpy as np

# Original data for x and y. Data is assumed to be generated by an unknown 
# function 'f', so that datay[i] = f(datax[i], *args), where *args are unknown
# parameters for the model class as a list.
datax = [] 
datay = [] 


def read_data(filepath = '../resources/data200.txt'):
    '''Reads data file to global variables datax and datay.
    
    Each line in data file should contain two floats, x and y, separated by white space.
    e.g. Call with path to file data200.txt from the course.
    
    Don't call more than once per script run as all the lines in file will be 
    appended again.
    '''
    lines = None
    with open(filepath, 'r') as f: 
        # f is alias for opened file inside this segment. 'with'-syntax is defined
        # to close the file as soon as segment is exited
        lines = f.readlines()
        
    for line in lines:
        # Strip white-spaces from line ends and split the line left from whitespaces,
        # i.e. line = "a b c" -> d = line.split() -> d = ['a'. 'b', 'c']
        x, y = line.strip().split()  
        x, y = float(x), float(y)
        datax.append(x)
        datay.append(y)
    

def plot(x, y, title):
    '''Plot x and y of fitted curve against original data (datax and datay) as 
    scatter plot with variable title.
    
    Assumes that read_data has been called. Uses matplotlib.
    '''
    from matplotlib import pyplot as plt
    
    miny = min(datay)
    maxy = max(datay)
    plt.scatter(datax, datay, marker = "x", color = 'r')
    plt.plot(x, y)
    plt.axis([0, 2.0, miny - 0.5, maxy + 0.5])
    plt.plot()
    plt.title(title)
    plt.show()
    

def calc_rss(func, *args):
    '''Calculate residual sum of squares for the function with args against 
    datax and datay.
    '''
    rss = 0.0
    for i, x in enumerate(datax):
        y = func(x, *args)
        sq = (datay[i] - y) ** 2 # a ** b = a to power b
        rss += sq
    
    return rss 


def codelen(func, *args):
    '''Calculate code length for the function with args, i.e. rss + model 
    complexity. 
    '''
    rss = calc_rss(func, *args)
    fst_part = (len(datax)/2) * np.log2(rss)
    snd_part = (float(len(args) + 1) / 2) * np.log2(len(datax))
    return fst_part, snd_part


def func(x, b, c, d, e, f, g, h):
    '''Function to fit, two additive sin-waves.
    '''
    return c * np.sin(b + np.dot(x, 10)) + f * np.sin(g + np.dot(x, d)) + e


def fit_curve():
    '''Fit the curve defined in 'func' to the data read.
    '''
    # Read the data to global variables
    read_data() 
    # Get optimal parameters values and covariance matrix. If you change func's
    # parameter size, adjust p0's length.
    popt, popcov = curve_fit(func, datax, datay, maxfev = 6000, p0 = [0.2, 0.3, 1, 2, 3, 4, 1])
    # Get linear space samples for curve plotting purposes (use np.linspace so 
    # that the resulting x is np.array).
    x = np.linspace(0.01, 2, 200)
    # Get our assumed models predictions for each x, i.e. y is a np.array. 
    # This can be done because x is np.array so numpy handles the calling for 
    # all the elements in the np.array separately. If x would be basic python
    # list, would result in error (you would have to call 'func' for each element
    # in the list in a for-loop and append the results in y).
    y = func(x, *popt)
    # Get code length 
    fp, sp = codelen(func, *popt)
    title = "codelen: {} + {} = {}, args = {}".format(fp, sp, fp + sp, len(popt) + 1)
    print title
    # Plot original data and fitted curve.
    plot(x, y, title)


if __name__ == '__main__':
    # If called from command line, etc., call fit_curve.
    fit_curve()
